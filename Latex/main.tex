\documentclass[12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage{listings}
\usepackage{c/style} % include custom style for C

\title{Generazione automa caratteristico parsing bottom-up LR(0) }
\author{
        Sandri Fabrizio \\ \\        
        Dipartimento di Ingegneria e Scienza dell'Informazione\\
        Università di Trento
}

\date{\today}


\begin{document}
\maketitle

\section{Introduzione}
In questo report si vuole analizzare ed implementare la procedura di generazione di un automa caratteristico per il parsing bottom-up di tipo LR(0). Fra i vari tipi di parsing visti a lezione il parsing LR(0) è un tipo di parsing per cui si legge l'input da sinistra a destra e si produce una derivazione di tipo rightmost a partire dalla grammatica data in input.

\paragraph{Il problema:} 
il primo step del parsing bottom-up è quello di generare un automa caratteristico a partire dalla grammatica letta in input per poi andare a formare una tabella di parsing. In questo report ci focalizzeremo solamente sulla parte di generazione dell'automa caratteristico.

\section{Definizioni}
L'automa caratteristico è formato da un insieme di stati interconnessi da una funzione di transizione $\tau$ definita su coppie di stati. Se diciamo S gli stati dell'automa e V il vocabolario della grammatica considerata allora definiamo la funzione di transizione
$$
\tau \colon (S, V) \to S
$$
Ogni stato contiene degli LR(0)-items : alcuni di questi item faranno parte del kernel, mentre altri fanno parte della closure del kernel.\\

La tecnica di costruzione dell'automa caratteristico è incrementale: andiamo a popolare un set di stati definendo mano a mano la funzione di transizione, fino a saturazione.


\section{Strutture dati}
Per implementare l'automa caratteristico dato in output dal programma e la grammatica fornita in input si è cercato di seguire uno stile di programmazione il più astratto e intuitivo possibile, in modo da rendere la lettura del codice di facile comprensione. In particolare il linguaggio C non offrendo delle strutture dati pre fabbricate ci ha obbligati a definirne alcune, sfruttando la keyword $struct$.\\

Analizzeremo nei prossimi paragrafi le decisioni implementative prese per realizzare le varie parti necessarie alla costruzione di un automa caratteristico. Riportiamo in breve di quali importanti strutture dati ci avvaleremo durante la trattazione:
\begin{enumerate}
\item Produzione
\item Grammatica
\item Item LR(0)
\item Stato dell'automa caratteristico
\item Funzione di transizione
\item Automa caratteristico
\end{enumerate}

\subsection{Produzione}
Tutto il codice si basa su questa struttura dati, la produzione. Ogni produzione è una struttura minimale composta da 3 parti:
\begin{list}{-}{}
\item char driver : il driver della produzione ;
\item char[ ] body : stringa contenente il body della produzione ;
\item int production\_id : valore intero utilizzato per controllare in maniera efficiente se le produzioni memorizzate in due item distinti sono uguali. Se driver e body di due item distinti avranno lo stesso $production\_id$ vorrà dire che la produzione memorizzata nell'item sarà identica e meno della posizione del marker che può essere differente.
\end{list}

Riportiamo ora il codice utilizzato per rappresentare una produzione.
\lstinputlisting[language=C,style=c]{c/fragments/production.c}

\subsection{Grammatica}
Il primo step nella procedura di generazione dell'automa caratteristico è quello di leggere la grammatica fornita in input dall'utente e memorizzarla. Vista la definizione di $production$ fornita in precedenza definiamo la grammatica come un array di produzioni.\\

Ogni nuova produzione sarà inserita nella grammatica sfruttando la funzione $addProduction()$ \\

Riportiamo qui sotto il codice utilizzato per rappresentare la grammatica.
\lstinputlisting[language=C,style=c]{c/fragments/grammar.c}



\subsection{Item LR(0)}
Gli stati dell'automa caratteristico saranno formati da Item LR(0), ovvero Item associati ad una singola produzione e ad un marker
$$
A \to \alpha\cdot\beta
$$ 
Dove il simbolo $\cdot$ indica la posizione del marker all'interno del body della produzione. \\

A livello implementativo un modo efficiente per implementare un Item LR(0) è quello di utilizzare una struct contenente le seguenti informazioni:
\begin{list}{-}{}
\item production prod : la produzione associata all'item e definita sfruttando la definizione di produzione vista in precedenza;
\item int marker\_position : un valore intero rappresentante la posizione del marker all'interno dell'item;
\item bool isKernelProduction : settato a true per indicare che un Item fa parte del Kernel di uno stato.
\end{list}

Riportiamo ora il codice utilizzato per rappresentare questo tipo di item.
\lstinputlisting[language=C,style=c]{c/fragments/lr0_item.c}

\subsection{Stato dell'automa caratteristico}
Ogni stato dell'automa caratteristico sarà definito da un identificativo numerico: la posizione nell'array $automa$ definito nella prossima sezione "Automa caratteristico". Descriveremo il singolo stato attraverso i seguenti attributi:
\begin{list}{-}{}
\item lr0\_item items[50] : dalla definizione sappiamo che ogni stato dell'automa caratteristico sarà composto da un insieme di LR(0) items, in questo caso definito tramite un array. Alcuni di questi items inoltre faranno parte del kernel dello stato.
\item transaction transactions[AUTOMA\_STATES\_COUNT] : un insieme di transizioni uscenti dallo stato corrente e dirette nel verso degli altri stati. Anche in questo caso sfruttiamo la definizione di $struct transaction$ definita in precedenza.
\item state\_type type : indica il tipo di stato corrente che può essere uno stato fra i seguenti : $normale$, di $accept$ oppure $finale$.
\item int items\_count : numero totale di items presenti nello stato(compresi quelli facenti parte del kernel)
\item int kernel\_items\_count : numero di items che sono parte del kernel. Questa variabile è aggiunta al solo scopo di velocizzare la procedura di controllo della presenza di uno stato con lo stesso kernel nell'automa caratteristico. Se due stati hanno numero di items del kernel diverso, sicuramente non potranno essere uguali e quindi si saltano calcoli aggiuntivi.
\item int transaction\_count : numero di transizioni uscenti dallo stato
\end{list}

L'implementazione dello stato dell'automa caratteristico rispecchia esattamente i punti appena visti.
Riportiamo il codice utilizzato per rappresentare lo stato dell'automa.
\lstinputlisting[language=C,style=c]{c/fragments/automa_state.c}


\section{Input e Output}

\subsection{Input}

\subsection{Output}

\section{Testing}





\end{document}